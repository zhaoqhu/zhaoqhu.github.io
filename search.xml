<?xml version="1.0" encoding="utf-8"?>
<search>
  
    <entry>
      <title><![CDATA[Swoole Framework 学习]]></title>
      <url>/php/2020/01/03/php-swoole-learning/</url>
      <content type="text"><![CDATA[参考资料  Swoole官网  Swoole入门教程及文档]]></content>
      <categories>
        
          <category> PHP </category>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[ECMAScript6 学习]]></title>
      <url>/javscript/2020/01/03/javascript-es6/</url>
      <content type="text"><![CDATA[Module的语法ES6 模块不是对象，而是通过export命令显式指定输出的代码，再通过import命令输入。模块功能主要由两个命令构成：export和import。export命令用于规定模块的对外接口，import命令用于输入其他模块提供的功能。一个模块就是一个独立的文件。该文件内部的所有变量，外部无法获取。如果你希望外部能够读取模块内部的某个变量，就必须使用export关键字输出该变量。参考资料  ECMAScript6入门  ES6 In Depth: Modules]]></content>
      <categories>
        
          <category> javscript </category>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[MySQL优化]]></title>
      <url>/mysql/2020/01/02/mysql-optimize/</url>
      <content type="text"><![CDATA[参考资料  项目中常用的19条MySQL优化]]></content>
      <categories>
        
          <category> MySQL </category>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[electron学习笔记]]></title>
      <url>/electron/2019/12/26/electron/</url>
      <content type="text"><![CDATA[关于ElectronElectron是由Github开发，用HTML，CSS和JavaScript来构建跨平台桌面应用程序的一个开源库。 Electron通过将Chromium和Node.js合并到同一个运行时环境中，并将其打包为Mac，Windows和Linux系统下的应用来实现这一目的。Electron于2013年作为构建Github上可编程的文本编辑器Atom的框架而被开发出来。这两个项目在2014春季开源。目前它已成为开源开发者、初创企业和老牌公司常用的开发工具。Electron      Electron产品版本发布介绍        Electron产品版本发布  ChromiunChromiun版本发布Node.js]]></content>
      <categories>
        
          <category> electron </category>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Vue CLI学习笔记]]></title>
      <url>/vue/2019/12/09/vue-cli-learning/</url>
      <content type="text"><![CDATA[Vue CLI、Vue GUI、vue-cli-service、vue-router、vue-loaderVue CLI安装  Node 版本要求Vue CLI 需要 Node.js 8.9 或更高版本 (推荐 8.11.0+)。你可以使用 nvm 或 nvm-windows 在同一台电脑中管理多个 Node 版本。npm install -g @vue/cli# ORyarn global add @vue/cli  检查vue是否安装成功vue --version创建项目vue createvue ui这种是使用图形界面来创建项目，在命令行执行vue ui成功后浏览器会弹出一个http://localhost:8000的图形管理界面GUIVue GUI在命令行中执行vue ui 成功后，用浏览器打开Vue GUI,使用Vue GUI创建项目、管理项目、管理serve、编译项目build等。创建项目管理项目启动开发serve任务=&gt;serve=&gt;启动，等同于在命令行中执行下面的命令npx vue-cli-service serve编译项目任务=&gt;build=&gt;运行，等同于在命令行中执行下面的命令npx vue-cli-service build检查Webpack配置任务=&gt;inspect=&gt;运行Vue CLI配置在package.json文件的同目录下创建vue.config.jsmodule.exports = {	configureWebpack: {		entry: './src/main3223.js'//配置项目入口文件，默认的名称是main.js	}	pages: {		about: {			entry: 'src/pages/about/main.js',			template: 'public/about.html',			filename: 'about.html'		},		index: {			entry: 'src/pages/index/main.js',			template: 'public/index.html',			filename: 'index.html'		}	}}Vue CLI服务在一个 Vue CLI 项目中，@vue/cli-service 安装了一个名为 vue-cli-service 的命令。常用的vue-cliservice的命令有serve、build、inspect。package.json中配置vue-cli-service如下{  "scripts": {    "serve": "vue-cli-service serve",    "build": "vue-cli-service build",    "inspect": "vue-cli-service inspect"  }}使用npm可以执行npm run serve //开启servenpm run build //编译项目npm run inspect //审查webconfig配置文件Vue Router使用Vue GUI安装cli-plugin-router，会在原有的项目目录中生成以下目录和文件  /src/router/index.jsimport Vue from 'vue'import VueRouter from 'vue-router'import Home from '../views/Home.vue'Vue.use(VueRouter)const routes = [  {    path: '/',    name: 'home',    component: Home  },  {    path: '/about',    name: 'about',    // route level code-splitting    // this generates a separate chunk (about.[hash].js) for this route    // which is lazy-loaded when the route is visited.    component: () =&gt; import(/* webpackChunkName: "about" */ '../views/About.vue')  }]const router = new VueRouter({	mode: 'history',  routes})export default router      /src/views/About.view        /src/views/Home.view  Vue LoaderVue CLI插件Vue UI FrameworkVue UI框架  Element UI  Vuetify  Vue Material参考资料  Vue.js 文档  Vue CLI 文档  vue.config.js配置文档  vue-router文档  vue-loader文档  webpack配置文档]]></content>
      <categories>
        
          <category> vue </category>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Vue.js 学习笔记]]></title>
      <url>/vue/2019/12/02/vue-js-learning/</url>
      <content type="text"><![CDATA[直接在HTML页面 &lt;script&gt;引入的方式vue.js 视频学习  学习视频网址安装直接用 &lt;script&gt; 引入  开发版本包含完整的警告和调试模式  生产版本删除了警告，33.30KB min+gzipNPM命令行工具 (CLI)Vue实例创建一个实例var vm = new Vue({  // 选项})数据与方法除了数据属性，Vue 实例还暴露了一些有用的实例属性与方法。它们都有前缀 $，以便与用户定义的属性区分开来。例如：var data = { a: 1 }var vm = new Vue({  el: '#example',  data: data})vm.$data === data // =&gt; truevm.$el === document.getElementById('example') // =&gt; true// $watch 是一个实例方法vm.$watch('a', function (newValue, oldValue) {  // 这个回调将在 `vm.a` 改变后调用})实例生命周期钩子每个 Vue 实例在被创建时都要经过一系列的初始化过程——例如，需要设置数据监听、编译模板、将实例挂载到 DOM 并在数据变化时更新 DOM 等。同时在这个过程中也会运行一些叫做生命周期钩子的函数，这给了用户在不同阶段添加自己的代码的机会。比如 created 钩子可以用来在一个实例被创建之后执行代码：new Vue({  data: {    a: 1  },  created: function () {    // `this` 指向 vm 实例    console.log('a is: ' + this.a)  }})// =&gt; "a is: 1"``Vue自定义实例下面的这个Vue实例，包含了  数据data  自定义的方法click1、click2,  实例生命周期的钩子beforeCreate、created、beforeMount等  Vue实例的方法$watchvar vm = new Vue({	el: '#app', 	data: {		msg:'hello Vue',		author:{name:'Zhaoqhu'},		rawHtml:'&lt;span style='color:red'&gt;;this is a html span &lt;/span&gt;',		color:'red',		number: 10,		ok: false,		strArr: 'vue',		isShowMe: false,		hrefOrg: 'https://cn.vuejs.org/v2/guide/syntax.html#%E5%8F%82%E6%95%B0',		clsClickTest: 'div-click-test',		isClsRed: true	},	methods:{		click1: function(){			console.log('click 1');		},		click2: function(){			console.log('click2');		}	},	beforeCreate: function(){		console.log('beforeCreate');	},	created: function(){		console.log('created');	},	beforeMount: function(){		console.log('beforemount');	},	mounted: function(){		console.log('mounted');	},	beforeUpdate: function(){		console.log('beforeupdate');	},	updated: function(){		console.log('updated');	}	});data.author.name='zhao Q.H.';	console.log(vm);	console.log(data);	vm.$watch('a',function(newVal,oldVal){		console.log(newVal,oldVal);	});setTimeout(function(){	vm.$data.msg = "hello vue223";},5000);console.log(vm.$data.strArr.split('').reverse().join(''));模版语法插值文本数据绑定最常见的形式就是使用“Mustache”语法 (双大括号) 的文本插值：&lt;div id="app"&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/div&gt;原始HTML双大括号会将数据解释为普通文本，而非 HTML 代码。为了输出真正的 HTML，你需要使用 v-html 指令：&lt;div id="app"&gt;&lt;p id="rawHtmlA" v-html="rawHtml"&gt;&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;特性Mustache 语法不能作用在 HTML 特性上，HTML特性是指 id、class、href、title等遇到这种情况应该使用 v-bind 指令：&lt;div v-bind:class="color"&gt;hello red&lt;/div&gt;&lt;a v-bind:href="hrefOrg"&gt;跳转到官网&lt;/a&gt;&lt;div class="mar-top-30 font-30" v-bind:class="{fontRed:isClsRed}"&gt;使用Javascript表达式迄今为止，在我们的模板中，我们一直都只绑定简单的属性键值。但实际上，对于所有的数据绑定，Vue.js 都提供了完全的 JavaScript 表达式支持。&lt;p&gt;{{ number+1 }}&lt;/p&gt;&lt;p&gt;{{ ok ? 'YES' : 'NO' }}&lt;/p&gt;&lt;p&gt;{{ strArr.split('').reverse().join('') }}&lt;/p&gt;指令指令 (Directives) 是带有 v- 前缀的特殊特性。指令特性的值预期是单个 JavaScript 表达式 (v-for 是例外情况，稍后我们再讨论)。指令的职责是，当表达式的值改变时，将其产生的连带影响，响应式地作用于 DOM。回顾我们在介绍中看到的例子：参数一些指令能够接收一个“参数”，在指令名称之后以冒号表示。例如，v-bind 指令可以用于响应式地更新 HTML 特性：&lt;a v-bind:href="hrefOrg"&gt;跳转到官网&lt;/a&gt;&lt;div v-bind:class="clsClickTest"&gt;动态参数attributeName为动态参数，attributeValue为动态参数值eventName为动态参数,eventMethod为动态参数的静态方法&lt;a v-bind:[attributeName]="attributeValue"&gt;HTML动态属性和属性值&lt;/a&gt;&lt;a v-on:[eventName]="eventMethod"&gt;HTML动态事件和动态方法&lt;/a&gt;修饰符修饰符 (modifier) 是以半角句号 . 指明的特殊后缀，用于指出一个指令应该以特殊方式绑定。例如，.prevent 修饰符告诉 v-on 指令对于触发的事件调用 event.preventDefault()&lt;div @click="click1" v-bind:class="clsClickTest"&gt;	&lt;div v-on:click.stop="click2"&gt;	click me	&lt;/div&gt;&lt;/div&gt;缩写v- 前缀作为一种视觉提示，用来识别模板中 Vue 特定的特性。当你在使用 Vue.js 为现有标签添加动态行为 (dynamic behavior) 时，v- 前缀很有帮助，然而，对于一些频繁用到的指令来说，就会感到使用繁琐。同时，在构建由 Vue 管理所有模板的单页面应用程序 (SPA - single page application) 时，v- 前缀也变得没那么重要了。因此，Vue 为 v-bind 和 v-on 这两个最常用的指令，提供了特定简写：v-bind缩写&lt;!-- 完整语法 --&gt;&lt;a v-bind:href="url"&gt;...&lt;/a&gt;&lt;!-- 缩写 --&gt;&lt;a :href="url"&gt;...&lt;/a&gt;v-on缩写&lt;!-- 完整语法 --&gt;&lt;a v-on:click="doSomething"&gt;...&lt;/a&gt;&lt;!-- 缩写 --&gt;&lt;a @click="doSomething"&gt;...&lt;/a&gt;计算属性模板内的表达式非常便利，但是设计它们的初衷是用于简单运算的。在模板中放入太多的逻辑会让模板过重且难以维护。例如：&lt;div id="example"&gt;  {{ message.split('').reverse().join('') }}&lt;/div&gt;在这个地方，模板不再是简单的声明式逻辑。你必须看一段时间才能意识到，这里是想要显示变量 message 的翻转字符串。当你想要在模板中多次引用此处的翻转字符串时，就会更加难以处理。所以，对于任何复杂逻辑，你都应当使用计算属性。基础例子&lt;div id="example"&gt;  &lt;p&gt;Original message: "{{ message }}"&lt;/p&gt;  &lt;p&gt;Computed reversed message: "{{ reversedMessage }}"&lt;/p&gt;&lt;/div&gt;var vm = new Vue({  el: '#example',  data: {    message: 'Hello'  },  computed: {    // 计算属性的 getter    reversedMessage: function () {      // `this` 指向 vm 实例      return this.message.split('').reverse().join('')    }  }})计算属性缓存vs方法计算属性vs侦听属性计算属性的setter侦听器虽然计算属性在大多数情况下更合适，但有时也需要一个自定义的侦听器。这就是为什么 Vue 通过 watch 选项提供了一个更通用的方法，来响应数据的变化。当需要在数据变化时执行异步或开销较大的操作时，这个方式是最有用的。&lt;div id="watch-example"&gt;  &lt;p&gt;    Ask a yes/no question:    &lt;input v-model="question"&gt;  &lt;/p&gt;  &lt;p&gt;{{ answer }}&lt;/p&gt;&lt;/div&gt;&lt;!-- 因为 AJAX 库和通用工具的生态已经相当丰富，Vue 核心代码没有重复 --&gt;&lt;!-- 提供这些功能以保持精简。这也可以让你自由选择自己更熟悉的工具。 --&gt;&lt;script src="https://cdn.jsdelivr.net/npm/axios@0.12.0/dist/axios.min.js"&gt;&lt;/script&gt;&lt;script src="https://cdn.jsdelivr.net/npm/lodash@4.13.1/lodash.min.js"&gt;&lt;/script&gt;&lt;script&gt;var watchExampleVM = new Vue({  el: '#watch-example',  data: {    question: '',    answer: 'I cannot give you an answer until you ask a question!'  },  watch: {    // 如果 `question` 发生改变，这个函数就会运行    question: function (newQuestion, oldQuestion) {      this.answer = 'Waiting for you to stop typing...'      this.debouncedGetAnswer()    }  },  created: function () {    // `_.debounce` 是一个通过 Lodash 限制操作频率的函数。    // 在这个例子中，我们希望限制访问 yesno.wtf/api 的频率    // AJAX 请求直到用户输入完毕才会发出。想要了解更多关于    // `_.debounce` 函数 (及其近亲 `_.throttle`) 的知识，    // 请参考：https://lodash.com/docs#debounce    this.debouncedGetAnswer = _.debounce(this.getAnswer, 500)  },  methods: {    getAnswer: function () {      if (this.question.indexOf('?') === -1) {        this.answer = 'Questions usually contain a question mark. ;-)'        return      }      this.answer = 'Thinking...'      var vm = this      axios.get('https://yesno.wtf/api')        .then(function (response) {          vm.answer = _.capitalize(response.data.answer)        })        .catch(function (error) {          vm.answer = 'Error! Could not reach the API. ' + error        })    }  }})&lt;/script&gt;练习代码Javascript代码index.jsHTML代码参考资料  jekyll转义特殊字符]]></content>
      <categories>
        
          <category> vue </category>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[OAuth2 service microsoft]]></title>
      <url>/oauth2/2019/11/25/oAuth-2-service-microsoft/</url>
      <content type="text"><![CDATA[在网站中添加第三方microsoft帐号登录功能，方法和步骤访问authorization_endpoint。  authorization_endpoint的链接地址为https://login.microsoftonline.com/common/oauth2/v2.0/authorize?client_id=4ec1c7f2-9e38-4b8e-8073-5e6b68da2162&amp;response_type=code&amp;redirect_uri=http://localhost/oauth/callback_microsoft.php&amp;response_mode=query&amp;scope=openid%20profile%20email%20user.read&amp;state=12345&amp;prompt=consentauthorization_endpoint链接参数解释https://login.microsoftonline.com/common/oauth2/v2.0/authorize?client_id=4ec1c7f2-9e38-4b8e-8073-5e6b68da2162&amp; response_type=code&amp;redirect_uri=http://localhost/oauth/callback_microsoft.php&amp;response_mode=query&amp;scope=openid%20offline_access%20https%3A%2F%2Fgraph.microsoft.com%2Fuser.read&amp; //scope值需要rawurlencode()state=12345&amp; //state值需要rawurlencode();这个参数值可以自定义，并且会自动返回附加到回调地址上，prompt=consent//这个值，会使用户弹出一个登陆的界面访问authorization_endpoint的方式  使用JS访问authorization_endpointwindow.location.href = "https://login.microsoftonline.com/common/oauth2/v2.0/authorize?client_id=4ec1c7f2-9e38-4b8e-8073-5e6b68da2162&amp;response_type=code&amp;redirect_uri=http://localhost/oauth/callback_microsoft.php&amp;response_mode=query&amp;scope=openid%20profile%20email%20user.read&amp;state=12345&amp;prompt=consent";*使用PHP访问authorization_endpointheader("Location: https://login.microsoftonline.com/common/oauth2/v2.0/authorize?client_id=4ec1c7f2-9e38-4b8e-8073-5e6b68da2162&amp;response_type=code&amp;redirect_uri=http://localhost/oauth/callback_microsoft.php&amp;response_mode=query&amp;scope=openid%20profile%20email%20user.read&amp;state=12345&amp;prompt=consent");访问token_endpoint。$url_token = "https://login.microsoftonline.com/common/oauth2/v2.0/token";$data['client_id'] = '4ec1c7f2-9e38-4b8e-8073-5e6b68da2162';$scope = "openid profile email user.read";//$scope = "";$data['scope'] = $scope;$data['code'] = $_GET['code'];//这个值是访问访问authorization_endpoint的URL后自动返回的$data['redirect_uri'] = 'http://localhost/oauth/callback_microsoft.php';$data['grant_type'] = 'authorization_code';$data['client_secret'] = 'rlPw-4rgooGre:@8D?90p6py=LOPMG_0';$res = post_url($url_token,$data);$objToken = json_decode($res);访问userinfo_endpoint$url_userinfo = "https://graph.microsoft.com/v1.0/me";$header[] = "Authorization: ".$objToken-&gt;token_type." ".$objToken-&gt;access_token;//var_dump($url_userinfo,$header);die;$resUserInfo = get_url($url_userinfo,$header);var_dump(666,$resUserInfo);die;function get_url($url,$data){	$ch = curl_init();	curl_setopt($ch, CURLOPT_URL, $url);	curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);	curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, FALSE); 	curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, FALSE); 	curl_setopt($ch, CURLOPT_CUSTOMREQUEST,"GET"); 	curl_setopt($ch, CURLOPT_HTTPHEADER, $data);	curl_setopt($ch, CURLOPT_PROXY, '127.0.0.1');	curl_setopt($ch, CURLOPT_PROXYPORT, '1080');	$output = curl_exec($ch);	if($output === false)	  {	      echo 'Curl error: ' . curl_error($ch);	  }	curl_close($ch);	return $output;}App registrations创建步骤1、访问https://portal.azure.com/#allservices2、Identity=&gt;App registrations=&gt;New registration3、registration主要参数有Application (client) ID，client secrect,创建方法选中已创建的registration=&gt;Certificates &amp; secrets=&gt; New client secrect4、开发过程中程序代码里client_id ，client_secret，redirect_uri，这三项的值，需要registration提供。参考资料  https://docs.microsoft.com/en-us/azure/active-directory/develop/v2-oauth2-auth-code-flow  https://docs.microsoft.com/en-us/graph/api/user-get?view=graph-rest-1.0&amp;tabs=http]]></content>
      <categories>
        
          <category> OAuth2 </category>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[OAuth2 service google]]></title>
      <url>/oauth2/2019/10/29/oAuth-2-service-google/</url>
      <content type="text"><![CDATA[在网站中添加第三方google帐号登录功能，方法和步骤访问authorization_endpoint。  authorization_endpoint的链接地址为https://accounts.google.com/o/oauth2/v2/auth?response_type=code&amp;scope=openid%20profile%20email&amp;redirect_uri=http://localhost/oauth/callback.php&amp;client_id=825260887949-tpka28ca3l4pacbjq83bdm1lnft58aga.apps.googleusercontent.com&amp;state=kwqrurwwlowpvnnprswlqxvwnsnwyymznrmupqsqvlpuumztvvdo&amp;access_type=offline&amp;prompt=consentauthorization_endpoint链接参数解释https://accounts.google.com/o/oauth2/v2/auth?response_type=code&amp;scope=openid%20profile%20email&amp; //scope值需要rawurlencode()redirect_uri=http://localhost/oauth/callback.php&amp;//redirect_uri值需要rawurlencode()client_id=825260887949-tpka28ca3l4pacbjq83bdm1lnft58aga.apps.googleusercontent.com&amp;//client_id值需要rawurlencode()state=kwqrurwwlowpvnnprswlqxvwnsnwyymznrmupqsqvlpuumztvvdo&amp;//state值需要rawurlencode();这个参数值可以自定义，并且会自动返回附加到回调地址上，access_type=offline&amp;prompt=consent//这个值，会使用户弹出一个登陆的界面访问authorization_endpoint的方式  使用JS访问window.location.href = https://accounts.google.com/o/oauth2/v2/auth?response_type=code&amp;scope=openid%20profile%20email&amp;redirect_uri=http://localhost/oauth/callback.php&amp;client_id=825260887949-tpka28ca3l4pacbjq83bdm1lnft58aga.apps.googleusercontent.com&amp;state=kwqrurwwlowpvnnprswlqxvwnsnwyymznrmupqsqvlpuumztvvdo&amp;access_type=offline&amp;prompt=consent  使用PHP访问header("Location: https://accounts.google.com/o/oauth2/v2/auth?response_type=code&amp;scope=openid%20profile%20email&amp;redirect_uri=http://localhost/oauth/callback.php&amp;client_id=825260887949-tpka28ca3l4pacbjq83bdm1lnft58aga.apps.googleusercontent.com&amp;state=kwqrurwwlowpvnnprswlqxvwnsnwyymznrmupqsqvlpuumztvvdo&amp;access_type=offline&amp;prompt=consent");访问token_endpoint。$data = array();$data['client_id'] = '825260887949-tpka28ca3l4pacbjq83bdm1lnft58aga.apps.googleusercontent.com';$data['client_secret'] = 'CeTlkOnFl3stgkTT4JgcxbWC';$data['grant_type'] = 'authorization_code';$data['redirect_uri'] = 'http://localhost/oauth/callback.php';$data['scope'] = '';$data['code'] = trim($_GET['code']); //这个值是访问访问authorization_endpoint的URL后自动返回的$url = 'https://www.googleapis.com/oauth2/v4/token';$res = post_url($url,$data);function post_url($url,$data){	$ch = curl_init();	curl_setopt($ch, CURLOPT_URL, $url);	curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);	curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, FALSE);	curl_setopt($ch, CURLOPT_SSL_VERIFYHOST,FALSE);	curl_setopt($ch, CURLOPT_POST, 1);	curl_setopt($ch, CURLOPT_POSTFIELDS, $data);	curl_setopt($ch, CURLOPT_PROXY, '127.0.0.1');	curl_setopt($ch, CURLOPT_PROXYPORT, '1080');	$output = curl_exec($ch);	  if($output === false)  {      echo 'Curl error: ' . curl_error($ch);  }  curl_close($ch);	return $output; }访问userinfo_endpoint$header[] = 'Authorization:'.$_SESSION['oauth2_google_token_type'].' '.$_SESSION['oauth2_google_access_token'];$request_url = "https://www.googleapis.com/oauth2/v2/userinfo";$res = get_url($request_url,$header);var_dump($res);die;function get_url($url,$data){	$ch = curl_init();	curl_setopt($ch, CURLOPT_URL, $url);	curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);	curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, FALSE); 	curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, FALSE); 	curl_setopt($ch, CURLOPT_CUSTOMREQUEST,"GET"); 	curl_setopt($ch, CURLOPT_HTTPHEADER, $data);	//curl_setopt($ch, CURLOPT_PROXY, '127.0.0.1');	//curl_setopt($ch, CURLOPT_PROXYPORT, '1080');	$output = curl_exec($ch);	if($output === false)	  {	      echo 'Curl error: ' . curl_error($ch);	  }	curl_close($ch);	return $output;}OAuth 2.0 client IDs创建步骤1、访问 Google API Console2、project=&gt;Credentials=&gt;OAuth client ID=&gt;Web application3、OAuth 2.0 client ID的主要参数有Client ID，Client secrect，Authorized redirect URIs4、开发过程中程序代码里client_id ，client_secret，redirect_uri，这三项的值，需要OAuth 2.0 client ID提供。google提供的在线使用API工具https://accounts.google.com/o/oauth2/v2/auth? scope=https%3A%2F%2Fwww.googleapis.com%2Fauth%2Fdrive.metadata.readonly&amp; access_type=offline&amp; include_granted_scopes=true&amp; state=state_parameter_passthrough_value&amp; redirect_uri=https://developers.google.com/oauthplayground&amp; response_type=code&amp; client_id=825260887949-tpka28ca3l4pacbjq83bdm1lnft58aga.apps.googleusercontent.com参数解释https://accounts.google.com/o/oauth2/v2/auth? scope=https%3A%2F%2Fwww.googleapis.com%2Fauth%2Fdrive.metadata.readonly&amp; access_type=offline&amp; include_granted_scopes=true&amp; state=state_parameter_passthrough_value&amp;//自定义我们网站里面需要使用的参数，会自动附加到回调地址上， redirect_uri=https://developers.google.com/oauthplayground&amp; //这个是google提供的在线API工具地址，这个回调地址需要添加到credentials response_type=code&amp; client_id=825260887949-tpka28ca3l4pacbjq83bdm1lnft58aga.apps.googleusercontent.com//这个是需要在google API console里创建credentials，然后在里面有client_id参考资料  Google OAuth 2 API 在线工具  https://developers.google.com/identity/protocols/OpenIDConnect]]></content>
      <categories>
        
          <category> OAuth2 </category>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Ubuntu 14.04 lts 升级到 16.04 lts]]></title>
      <url>/linux/2019/10/11/ubuntu14.04-lts-to-16.04-lts/</url>
      <content type="text"><![CDATA[故障描述升级到16.04后，只有命令行模式，没有网络，apt-get命令失效，故障原因解决方法重启电脑，同时一直按”Esc”键，进入GRUB界面apt-get错误apt: relocation error: version GLIBCXX_3.4.21 not defined in file libstdc++.so.6 with link time reference解决办法：需要网络可以正常访问外网，执行下面的命令$ wget http://security.ubuntu.com/ubuntu/pool/main/g/gcc-5/libstdc++6_5.4.0-6ubuntu1~16.04.10_amd64.debsudo dpkg -i libstdc++6_5.4.0-6ubuntu1~16.04.10_amd64.deb# I also found this helpful$ sudo apt-get -f install命令行模式切换到图形界面模式$ service lightdm start参考资料  命令行模式切换到图形界面模式  apt-get报错解决办法  修复ubuntu16.04，GRUB解决办法]]></content>
      <categories>
        
          <category> linux </category>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[chatroom]]></title>
      <url>/2019/10/09/chatroom/</url>
      <content type="text"><![CDATA[登录      参数  用户名：userName, 房间：roomId, 是否为主播：is_host        检查userName,roomId  如果userName,roomId的值为空则返回错误的提示信息。        检查某用户在某房间是否为主播  例如：userName的值为zhaoQH,roomId的值为北京666,检查zhaoQH在北京666的房间是否为主播        检查某用户是否已在房间  ]]></content>
      <categories>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Node.js学习笔记]]></title>
      <url>/node.js/2019/10/08/Nodejs-learning/</url>
      <content type="text"><![CDATA[安装  参考链接Node.js升级windows下升级windows下升级Nodejs比较简单，直接下载msi文件，安装覆盖原安装路径就可以了。由于众所周知的原因，国内访问Nodejs官网下载Nodejs安装文件时间非常DT的事，此处附上淘宝的国内镜像源，速度非常快。linux下升级  检查Node的当前版本$ node -v  清除npm cache$ sudo npm chache clean -f  node有一个模块叫n（这名字可够短的。。。），是专门用来管理node.js的版本的。$ npm install -g n  升级到最新稳定版本$ n stable  升级到指定版本$ n v4.4.7或者$ n 4.4.7npm升级  查看当前版本$ npm -v  升级至最新版本或者指定版本 @符号后面可以添加你想更新到的版本号。 latest代表是最新版本$ npm install npm@latest -g安装淘宝 NPM 镜像这是一个完整 npmjs.org 镜像，你可以用此代替官方版本(只读)，同步频率目前为 10分钟 一次以保证尽量与官方服务同步。$ npm install -g cnpm --registry=https://registry.npm.taobao.org使用cnpm安装模块从 registry.npm.taobao.org 安装所有模块. 当安装的时候发现安装的模块还没有同步过来, 淘宝 NPM 会自动在后台进行同步, 并且会让你从官方 NPM registry.npmjs.org 进行安装. 下次你再安装这个模块的时候, 就会直接从 淘宝 NPM 安装了.其它命令支持 npm 除了 publish 之外的所有命令, 如:$ cnpm install [name]补充常用npm命令$ npm -v          #显示版本，检查npm 是否正确安装。$ npm install express   #安装express模块$ npm install -g express  #全局安装express模块$ npm install --save express #会把express包安装到该目录下的node_modules目录中,会在package.json的dependencies属性下添加express,之后运行npm install 或者 npm install -production或者著名NODE_ENV变量值为production时，会自动安装express到node_module目录中.$ npm install --save-dev express #会把express包安装到该目录下的node_modules目录中,会在package.json的dependencies属性下添加express,之后运行npm install会自动安装express到node_module目录中但是执行npm install -production或者著名NODE_ENV变量值为production时，不会自动安装express到node_module目录中.$ npm install -D express # 等于npm install --save-dev express$ npm list         #列出已安装模块$ npm show express     #显示模块详情$ npm update        #升级当前目录下的项目的所有模块 $ npm update express    #升级当前目录下的项目的指定模块$ npm update -g express  #升级全局安装的express模块$ npm uninstall express  #删除指定的模块注：运行时需要用到的包使用npm install –save express，否则使用npm install –save-dev express。。参考资料  淘宝NPM镜像  https://github.com/tj/n  https://www.jb51.net/article/52409.htm  https://docs.npmjs.com/try-the-latest-stable-version-of-npm]]></content>
      <categories>
        
          <category> Node.js </category>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[browserify]]></title>
      <url>/node.js/2019/10/08/Browserify-watchify/</url>
      <content type="text"><![CDATA[介绍Browserify lets you require(‘modules’) in the browser by bundling up all of your dependencies.安装$ npm install -g browserify使用一  Here is a tutorial on how to use Browserify on the command line to bundle up a simple file called main.js along with all of its dependencies: main.jsvar unique = require('uniq');var data = [1, 2, 2, 3, 4, 5, 5, 5, 6];console.log(unique(data));  Install the uniq module with npm:npm install uniq  Now recursively bundle up all the required modules starting at main.js into a single file called bundle.js with the browserify command:browserify main.js -o bundle.js  Browserify parses the AST for require() calls to traverse the entire dependency graph of your project.Drop a single &lt;script&gt; tag into your html and you’re done!&lt;script src="bundle.js"&gt;&lt;/script&gt;使用二 browserify, watchify, socket.io-client, jquery、  安装browserify , socket.io-client, watchify$ npm i browserify --save-dev$ npm install --save socket.io-client$ npm i watchify --save-dev$npm i --save jquery  package.json{  "name": "app",  "version": "1.0.0",  "description": "",  "main": "main.js",  "scripts": {    "build": "browserify main.js -o ../server/public/bundle.js",    "watch": "watchify main.js -o bundle.js"  },  "author": "",  "license": "ISC",  "dependencies": {    "socket.io-client": "^2.3.0"  }}  main.js文件使用require引入js模块  执行命令，编译和监控文件$ npm run build$ npm run watch参考资料http://browserify.org/]]></content>
      <categories>
        
          <category> Node.js </category>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[jekyll学习笔记]]></title>
      <url>/jekyll/2019/09/29/jekyll-learning/</url>
      <content type="text"><![CDATA[jekyll安装 使用~ $ gem install jekyll~ $ jekyll new myblog~ $ cd myblog~/myblog $ jekyll serve //启动server~/myblog $ bundle exec jekyll server //windows system start jekyll server# =&gt; Now browse to http://localhost:4000jekyll代码块转义特殊字符如何显示呢{{  }} 具体如下： {% raw %}{{ msg }} {% endraw %}  参考资料  jekyll如何转义特殊字符]]></content>
      <categories>
        
          <category> jekyll </category>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[mediasoup]]></title>
      <url>/mediasoup/2019/09/27/mediasoup/</url>
      <content type="text"><![CDATA[learning mediasoup A WebRTC SFU for Node.jsFULL MESHMCU: MULTIPOINT CONTROL UNITSFU: SELECTIVE FORWARDING UNITmediasoup-clientmediasoup-client安装npm install mediasoup-client@3 --save浏览器端使用Node.js模块mediasoup-client      JavaScript ES6 plus CommonJS        browserify 、webpack、gulp  ubunto 安装mediasoupv3  新建mediasoupv3-zhaoqhu目录，分别创建app,server目录$ mkdir mediasoupv3-zhaoqhu$ mkdir server$ mkdir app$ cd server$ npm init$ sudo npm install mediasoup@3 --save --unsafe-perm=true --allow-root  检查gcc 版本 如果gcc版本小于 4.9，需要升级gcc到4.9以上，ubunto 14.04 lts 好像最高的gcc 版本是 4.8.5，升级 ubunto 到 16.04 lts首先添加ppa到库：$ sudo add-apt-repository ppa:ubuntu-toolchain-r/test$ sudo apt-get update$ sudo apt-get upgrade$ sudo apt-get $ sudo apt-get install gcc-4.8 g++-4.8$ sudo apt-get install gcc-4.9 g++-4.9$ sudo apt-get install gcc-5 g++-5mediasoup server.js分析const fs = require('fs');   //文件系统   	fs.readFileSync(path[,options]) //方法用于同步读取文件，返回一个字符串。	cert : fs.readFileSync(config.https.tls.cert),	key  : fs.readFileSync(config.https.tls.key)--------------------------------------const https = require('https');--------------------------------------const url = require('url'); //模块用于生成和解析URL。该模块使用前，必须加载。	url.parse(urlString[, parseQueryString[, slashesDenoteHost]]) //The url.parse() method takes a URL string, parses it, and returns a URL object.	const u = url.parse(info.request.url, true);const protoo = require('protoo-server');const mediasoup = require('mediasoup');----------------------------------------const express = require('express'); //Express 是一个简洁而灵活的 node.js Web应用框架, 提供了一系列强大特性帮助你创建各种 Web 应用，和丰富的 HTTP 工具。const expressApp = express();expressApp.use()和app.METHOD()(METHOD包括get(),put(),post(),delete())都是express应用层中间件，处理用户浏览器端发起到服务端的请求，但是一般情况下expressApp.use()都写在app.METHOD()前面，然后在use()中间件函数里写一些公共的代码，然后next()到METHOD()中间件函数中。expressApp.use(bodyParser.json()); //expressApp.param([name],callback); //执行Express路由(expressApp.get(),expressApp.post(),expressApp.put(),expressApp.delete()),会触发expressApp.param()这个方法，expressApp.param('roomId', (req, res, next, roomId) =&gt;{	// The room must exist for all API requests.	if (!rooms.has(roomId))	{		const error = new Error(`room with id "${roomId}" not found`);		error.status = 404;		throw error;	}	req.room = rooms.get(roomId);	next();});----------------------------------------const bodyParser = require('body-parser');body-parser是express框架常用的一个中间件，作用是对post请求的请求体进行解析。结合express().use()和express().METHOD()的使用方法，expressApp.use(bodyParser.json()); expressApp.post('/rooms/:roomId/broadcasters', async (req, res, next) =&gt;{})-----------------------------------------const AwaitQueue = require('awaitqueue');这个Node.js组件是Mediasoup的作者编写的，-----------------------------------------const Logger = require('./lib/Logger');const Room = require('./lib/Room');const interactiveServer = require('./lib/interactiveServer');const interactiveClient = require('./lib/interactiveClient');  multiparty引入的moudleconst config = require('./config/config');const fs = require('fs');const http = require('http');-------------------------------const spdy = require('spdy');//配置http访问方式-------------------------------const express = require('express');--------------------------------const compression = require('compression');app.user(compression()) //通过 Gzip 压缩，有助于显著降低响应主体的大小，从而提高 Web 应用程序的速度。可使用压缩中间件进行 Express 应用程序中的 gzip 压缩。例如--------------------------------const mediasoup = require('mediasoup');const AwaitQueue = require('awaitqueue');const Logger = require('./lib/Logger');const Room = require('./lib/Room');const utils = require('./util');----------------------------------------const base64 = require('base-64');// 加密解密参数state : base64.encode(JSON.stringify({	roomId : req.query.roomId,	peerId : req.query.peerId,	code   : utils.random(10)}))const state = JSON.parse(base64.decode(req.query.state));----------------------------------------------const passport = require('passport');-------------------------------------const { Issuer, Strategy } = require('openid-client');const session = require('express-session');mediasoup-client知识点  new mediasoupClient.Device(); //实例化mediasoupClent  await this._mediasoupDevice.load()  this._mediasoupDevice.createSendTransport()  this._mediasoupDevice.createRecvTransport()  this._mediasoupDevice.canProduce();mediasoup知识点  const mediasoupWorker = mediasoup.createWorker()  const mediasoupRouter = mediasoupWorker.createRouter({ mediaCodecs });  this._mediasoupRouter.canConsume()  this._mediasoupRouter.rtpCapabilities;  mediasoupWorker.close();  const audioLevelObserver = await mediasoupRouter.createAudioLevelObserver();  const transport = await this._mediasoupRouter.createWebRtcTransport();  transport.setMaxIncomingBitrate(maxIncomingBitrate); }  transport.connect({ dtlsParameters });  transport.restartIce();  await transport.produce({ kind, rtpParameters, appData })  await transport.getStats();  consumer = await transport.consume();multiparty 工作流程      app-&gt;src-&gt;index.js    logger.debug(‘DOM ready’);        app-&gt;src-&gt;RoomClient.js  export default class RoomClient{	static init(data){}	constructor({ roomId, peerId, device, useSimulcast, produce, consume, forceTcp }){logger.debug('constructor() [roomId: "%s", peerId: "%s", device: "%s", useSimulcast: "%s", produce: "%s", consume: "%s", forceTcp: "%s"]',roomId, peerId, device.flag, useSimulcast, produce, consume, forceTcp);}	------------------------------------------	close(){logger.debug('close()');}	------------------------------------------	_startKeyListener(){}	_startDevicesListener(){}	login(){}	logout(){}	closeLoginWindow(){}	_soundNotification(){logger.error('_soundAlert.play() | failed: %o', error);}	notify(text){}	timeoutCallback(callback){}	sendRequest(method, data){// 发送命令到服务端socketreturn new Promise((resolve, reject) =&gt;		{			if (!this._signalingSocket)			{				reject('No socket connection.');			}			else			{				this._signalingSocket.emit(					'request',					{ method, data },					this.timeoutCallback((err, response) =&gt;					{						if (err)						{							reject(err);						}						else						{							resolve(response);						}					})				);			}		});		}	async changeDisplayName(displayName){logger.debug('changeDisplayName() [displayName:"%s"]', displayName);}	async changeProfilePicture(picture){logger.debug('changeProfilePicture() [picture: "%s"]', picture);}	async sendChatMessage(chatMessage){logger.debug('sendChatMessage() [chatMessage:"%s"]', chatMessage);}	saveFile(file){}	handleDownload(magnetUri){}	_handleTorrent(torrent){}	async shareFiles(files){}	async _sendFile(magnetUri){logger.debug('sendFile() [magnetUri: %o]', magnetUri);}	async getServerHistory(){logger.debug('getServerHistory()');}	------------------------------------------	async muteMic(){logger.debug('muteMic()');}	async unmuteMic(){logger.debug('unmuteMic()');}	------------------------------------------	async updateSpotlights(spotlights){logger.debug('updateSpotlights()');}	async changeAudioDevice(deviceId){logger.debug('changeAudioDevice() [deviceId: %s]', deviceId);}	async changeVideoResolution(resolution){logger.debug('changeVideoResolution() [resolution: %s]', resolution);}	async changeWebcam(deviceId){logger.debug('changeWebcam() [deviceId: %s]', deviceId);}	setSelectedPeer(peerId){logger.debug('setSelectedPeer() [peerId:"%s"]', peerId);}	async modifyPeerConsumer(peerId, type, mute){logger.debug('modifyPeerConsumer() [peerId:"%s", type:"%s"]',peerId,type);}	async _pauseConsumer(consumer){logger.debug('_pauseConsumer() [consumer: %o]', consumer);}	async _resumeConsumer(consumer){logger.debug('_resumeConsumer() [consumer: %o]', consumer);}	async sendRaiseHandState(state){logger.debug('sendRaiseHandState: ', state);}	async join({ joinVideo }){		this._signalingSocket = io(this._signalingUrl);		logger.debug('signaling Peer "connect" event');		this._signalingSocket.on('connect',()=&gt;{logger.debug('signaling Peer "connect" event');});		this._signalingSocket.on('disconnect',()=&gt;{logger.warn('signaling Peer "disconnect" event');});		this._signalingSocket.on('close',()=&gt;{logger.warn('signaling Peer "close" event');});		this._signalingSocket.on('request',async (request, cb)=&gt;{logger.debug(				'socket "request" event [method:%s, data:%o]',				request.method, request.data);				});		this._signalingSocket.on('notification', async (notification)=&gt;{			switch (notification.method)			{				case 'roomReady':{}				case 'roomLocked':{}				case 'lockRoom':{}				case 'unlockRoom':{}				case 'activeSpeaker':{}				case 'changeDisplayName':{}				case 'changeProfilePicture':{}				case 'auth':{}				case 'chatMessage':{}				case 'sendFile':{}				case 'producerScore':{}				case 'newPeer':{}				case 'peerClosed':{}				case 'consumerClosed':{}				case 'consumerPaused':{}				case 'consumerResumed':{}				case 'consumerLayersChanged':{}				case 'consumerScore':{}			}			});		this._signalingSocket.on('connect',()=&gt;{});		this._signalingSocket.on('connect',()=&gt;{});		this._signalingSocket.on('connect',()=&gt;{});		this._signalingSocket.on('connect',()=&gt;{});		this._signalingSocket.on('connect',()=&gt;{});		this._signalingSocket.on('connect',()=&gt;{});	}	async _joinRoom({ joinVideo }){		logger.debug('_joinRoom()');		this._mediasoupDevice = new mediasoupClient.Device(); //实例化mediasoupClent		const routerRtpCapabilities = await this.sendRequest('getRouterRtpCapabilities') //socket.io发送mediasoup命令		await this._mediasoupDevice.load({ routerRtpCapabilities }); //mediasoup-client根据socket.io发送命令返回来的数据load()		if(this._produce){			//socket.io发送Producer命令			const transportInfo = await this.sendRequest( 'createWebRtcTransport',{forceTcp  : this._forceTcp,producing : true,consuming : false});			//定义并接收socket.io返回来的值			const {id,iceParameters,iceCandidates,dtlsParameters} = transportInfo;			//mediasoupClient创建发送通道			this._sendTransport = this._mediasoupDevice.createSendTransport({id,iceParameters,iceCandidates,dtlsParameters});			this._sendTransport.on('connect',(){})			this._sendTransport.on('produce',(){})		}		if(this._consumer){			//socket.io发送consumer创建webRTC通道			const transportInfo = await this.sendRequest('createWebRtcTransport',{forceTcp  : this._forceTcp,producing : false,consuming : true});			const {id,iceParameters,iceCandidates,dtlsParameters} = transportInfo;			//mediasoupClient创建接受通道			this._recvTransport = this._mediasoupDevice.createRecvTransport(			{				id,				iceParameters,				iceCandidates,				dtlsParameters			});		}		//socket.io发送join命令		const { peers } = await this.sendRequest(		'join',{displayName: displayName,picture: picture,device: this._device,			rtpCapabilities : this._consume				? this._mediasoupDevice.rtpCapabilities				: undefined		});			}	------------------------------------------	async lockRoom(){		logger.debug('lockRoom()');		//socket.io发送lockRoom命令		await this.sendRequest('lockRoom');	}	async unlockRoom(){		logger.debug('unlockRoom()');		//socket.io发送unlockRoom命令		await this.sendRequest('unlockRoom');	}	------------------------------------------	async enableMic(){		logger.debug(				'enableMic() | new selected audio device [device:%o]',device);		logger.debug('enableMic() | calling getUserMedia()');		this._micProducer = await this._sendTransport.produce(		{			track,			codecOptions :			{				opusStereo : 1,				opusDtx    : 1			},			appData : 			{ source: 'mic' }		});	}	async disableMic(){		logger.debug('disableMic()');		await this.sendRequest(				'closeProducer', { producerId: this._micProducer.id });	}	------------------------------------------	async enableScreenSharing(){}	async disableScreenSharing(){}	------------------------------------------	async enableWebcam(){		if (!this._mediasoupDevice.canProduce('video')		this._sendTransport.producetrack,					appData : 					{						source : 'webcam'					}				})	}	async disableWebcam(){		logger.debug('disableWebcam()');		this._webcamProducer = await this.sendRequest(				'closeProducer', { producerId: this._webcamProducer.id });	}	------------------------------------------	async _updateAudioDevices(){logger.debug('_updateAudioDevices()');}	async _updateWebcams(){logger.debug('_updateWebcams()');}	async _getAudioDeviceId(){logger.debug('_getAudioDeviceId()');}	async _getWebcamDeviceId(){logger.debug('_getWebcamDeviceId()');}}浏览器端browser和服务端server通信服务端地址：const url = wss://${hostname}:${port}/?peerId=${peerId}&amp;roomId=${roomId};服务端用到的roomId,和peerId是通过浏览器端定义并传递过去的browser通过初始化socket.io-client初始化socket.io-client默认向服务端socket.io服务发送connection命令，服务端socket.io监听到connection命令后，根据browser端socket.io-client传递过来的roomId参数，执行获取或者创建房间,async join(){this._signalingSocket = io(this._signalingUrl)}=============&gt;async function runWebSocketServer(){	const io = require('socket.io')(httpsServer);	io.on('connection', (socket) =&gt;	{		const { roomId, peerId } = socket.handshake.query;		if (!roomId || !peerId)		{			logger.warn('connection request without roomId and/or peerId');			socket.disconnect(true);			return;		}		logger.info(			'connection request [roomId:"%s", peerId:"%s"]', roomId, peerId);		queue.push(async () =&gt;		{			const room = await getOrCreateRoom({ roomId }); //创建房间			room.handleConnection({ peerId, socket }); //创建peer		})		.catch((error) =&gt;		{			logger.error('room creation or room joining failed:%o', error);			socket.disconnect(true);			return;		});	});}创建房间方法getOrCreateRoom({roomId})房间数量受到mediasoupWorkers的限制，mediasoupWorkers的数量是config配置文件里根据cpu的性能限制，在开启服务 node server.js运行时，就执行了runMediasoupWorkers()方法根据配置文件把mediasoupWorkers初始化成数组了，该数组包含了所有可用的mediasoupworker了，创建房间用到的方法是Room.js里面的create()方法，在执行create方法里面又通过传递参数mediasoupworker,创建了mediasoupRouter,创建房间成功后执行room.handleConnection方法,创建房间成功后执行this._notification(socket, ‘roomReady’)，发送命令roomReady给socket.io-client;async function getOrCreateRoom({ roomId }){	let room = rooms.get(roomId);	// If the Room does not exist create a new one.	if (!room)	{		logger.info('creating a new Room [roomId:%s]', roomId);		const mediasoupWorker = getMediasoupWorker();		room = await Room.create({ mediasoupWorker, roomId });		rooms.set(roomId, room);		room.on('close', () =&gt; rooms.delete(roomId));	}	return room;}async function runMediasoupWorkers(){	const { numWorkers } = config.mediasoup;	logger.info('running %d mediasoup Workers...', numWorkers);	for (let i = 0; i &lt; numWorkers; ++i)	{		const worker = await mediasoup.createWorker(			{				logLevel   : config.mediasoup.worker.logLevel,				logTags    : config.mediasoup.worker.logTags,				rtcMinPort : config.mediasoup.worker.rtcMinPort,				rtcMaxPort : config.mediasoup.worker.rtcMaxPort			});		worker.on('died', () =&gt;		{			logger.error(				'mediasoup Worker died, exiting  in 2 seconds... [pid:%d]', worker.pid);			setTimeout(() =&gt; process.exit(1), 2000);		});		mediasoupWorkers.push(worker);	}}/** * Get next mediasoup Worker. */function getMediasoupWorker(){	const worker = mediasoupWorkers[nextMediasoupWorkerIdx];	if (++nextMediasoupWorkerIdx === mediasoupWorkers.length)		nextMediasoupWorkerIdx = 0;	return worker;}服务端Room.js创建房间成功后,执行room.handleConnection，创建Peerpeer创建成功后执行peer._handlePeer(),创建一个peer对象，_handlePeer({ peer, consume })	{		logger.debug('_handlePeer() [peer:"%s"]', peer.id);		peer.data = {};		// Not joined after a custom protoo 'join' request is later received.		peer.data.consume = consume;		peer.data.joined = false;		peer.data.displayName = undefined;		peer.data.device = undefined;		peer.data.rtpCapabilities = undefined;		peer.data.raiseHandState = false;		// Have mediasoup related maps ready even before the Peer joins since we		// allow creating Transports before joining.		peer.data.transports = new Map();		peer.data.producers = new Map();		peer.data.consumers = new Map();		peer.socket.on('request', (request, cb) =&gt;		{			logger.debug(				'Peer "request" event [method:%s, peerId:%s]',				request.method, peer.id);			this._handleSocketRequest(peer, request, cb)				.catch((error) =&gt;				{					logger.error('request failed:%o', error);					cb(error);				});		});		peer.socket.on('disconnect', () =&gt;		{			if (this._closed)				return;			logger.debug('Peer "close" event [peerId:%s]', peer.id);			// If the Peer was joined, notify all Peers.			if (peer.data.joined)			{				this._notification(peer.socket, 'peerClosed', { peerId: peer.id }, true);			}			const index = this._lastN.indexOf(peer.id);			if (index &gt; -1) // We have this peer in the list, remove			{				this._lastN.splice(index, 1);			}			// Iterate and close all mediasoup Transport associated to this Peer, so all			// its Producers and Consumers will also be closed.			for (const transport of peer.data.transports.values())			{				transport.close();			}			this._peers.delete(peer.id);			// If this is the latest Peer in the room, close the room after a while.			if (this._peers.size === 0)			{				setTimeout(() =&gt;				{					if (this._closed)						return;					if (this._peers.size === 0)					{						logger.info(							'last Peer in the room left, closing the room [roomId:%s]',							this._roomId);						this.close();					}				}, 10000);			}		});	}工作流程  浏览器端通过join方法使用socket.io-client，发送connection命令，  服务端通过监听connection命令，创建mediasoupWorker,  然后在创建room和mediasoupRouter,  然后在创建Peer  然后通过socket.io发送给浏览器端roomReady命令ecmscript6 es6知识点  new Map();const rooms = new Map();rooms.has(roomId)rooms.get(roomId)rooms.set(roomId, room);      export default class RoomClient{} //在创建JavaScript模块时，export 语句用于从模块中导出函数、对象或原始值，以便其他程序可以通过 import 语句使用它们。        static function(){} //静态方法不能用 new 实例调用        … Spread syntax展开语法return (…args) =&gt;  ]]></content>
      <categories>
        
          <category> mediasoup </category>
        
      </categories>
      <tags>
        
          <tag> mediasoup </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[使用video.js播放dash、m3u8、mp4视频文件。]]></title>
      <url>/videojs/2019/09/26/videojs-play-dash-m3u8-mp4/</url>
      <content type="text"><![CDATA[使用video.js播放dash、m3u8、mp4视频文件。video.js播放Mp4&lt;head&gt;  &lt;link href="https://vjs.zencdn.net/7.6.5/video-js.css" rel="stylesheet"&gt;  &lt;!-- If you'd like to support IE8 (for Video.js versions prior to v7) --&gt;  &lt;script src="https://vjs.zencdn.net/ie8/1.1.2/videojs-ie8.min.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;  &lt;video id='my-video' class='video-js' controls preload='auto' width='640' height='264'  poster='MY_VIDEO_POSTER.jpg' data-setup='{}'&gt;    &lt;source src='MY_VIDEO.mp4' type='video/mp4'&gt;    &lt;source src='MY_VIDEO.webm' type='video/webm'&gt;    &lt;p class='vjs-no-js'&gt;      To view this video please enable JavaScript, and consider upgrading to a web browser that      &lt;a href='https://videojs.com/html5-video-support/' target='_blank'&gt;supports HTML5 video&lt;/a&gt;    &lt;/p&gt;  &lt;/video&gt;  &lt;script src='https://vjs.zencdn.net/7.6.5/video.js'&gt;&lt;/script&gt;&lt;/body&gt;video.js播放MPEG-DASH&lt;video id=example-video width=600 height=300 class="video-js vjs-default-skin" controls&gt; &lt;/video&gt;&lt;script src="video.js"&gt;&lt;/script&gt;&lt;script src="dash.all.js"&gt;&lt;/script&gt;&lt;script src="videojs-dash.min.js"&gt;&lt;/script&gt;&lt;script&gt;  var player = videojs('example-video');  player.src({ src: 'https://example.com/dash.mpd', type: 'application/dash+xml'});  player.play();&lt;/script&gt;video.js播放M3U8&lt;video id=example-video width=960 height=540 class="video-js vjs-default-skin" controls&gt;  &lt;source     src="https://example.com/index.m3u8"     type="application/x-mpegURL"&gt;&lt;/video&gt;&lt;script src="video.js"&gt;&lt;/script&gt;&lt;script src="videojs.hls.min.js"&gt;&lt;/script&gt;&lt;script&gt;var player = videojs('example-video');player.play();&lt;/script&gt;下载资源链接  video.js  dash.all.js  videojs-dash.min.js  videojs-hls.min.js参考资料  Video.js Setup  VideoJS MPEG-DASH博客=&gt;https://videojs.github.io/videojs-contrib-dash/  VideoJS m3u8博客=&gt;https://videojs.github.io/videojs-contrib-hls/]]></content>
      <categories>
        
          <category> videojs </category>
        
      </categories>
      <tags>
        
          <tag> videojs </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[mysql 储存 emoji表情符]]></title>
      <url>/mysql/2019/09/25/emoji-utf8mb4/</url>
      <content type="text"><![CDATA[mysql使用utf8mb4储存emoji表情符，mysql odbc driver 不兼容utf8mb4Unicode简介Unicode（中文：万国码、国际码、统一码、单一码）是计算机科学领域里的一项业界标准。它对世界上大部分的文字系统进行了整理、编码，使得计算机可以用更为简单的方式来呈现和处理文字。位于美国加州的Unicode组织允许任何愿意支付会费的公司和个人加入，其成员包含了主要的计算机软硬件厂商，例如Adobe系统、苹果公司、惠普、IBM、微软、施乐等。Unicode 自版本 2.0 开始保持了向后兼容，即新的版本仅仅增加字符，原有字符不会被删除或更名。目前版本是Unicode 12.1,统一码联盟在 1991 年首次发布了 The Unicode Standard。Unicode 的开发结合了国际标准化组织所制定的 ISO/IEC 10646，即通用字符集。基本多文种平面的字符的编码为 U+hhhh，其中每个 h 代表一个十六进制数字emoji表情符简介emoji（英语：emoji，日语：絵文字／えもじ emoji），最早由栗田穰崇（Shigetaka Kurita）创作,是一种形象化的符号，包括人的面部表情、肢体动作、各种动物、各种植物、各种食物、各种体育活动、各种交通工具、各种交通标志、各种国旗等形象化符号的总称。2010年10月发布的Unicode 6.0版首次收录emoji编码。emoji储存到mysql  utf8_unicode_ci和utf8mb4_unicode_ci的异同这两种collations所对应的字符都是UTF-8编码的一个子集。utf8_unicode_ci最多能找到3个字节的Unicode编码，而utf8mb4_unicode_ci则能找到4个字节的编码。由于调整后的UTF-8编码格式规定最多使用4字节（原来是6字节）编码，所以utf8mb4系列可以说是覆盖了整个Unicode编码。由于utf8_unicode_ci最多能找到3个字节的编码，意味着它只支持BMP中的字符，对于SMP与SIP以及其他头一字节不为0x00、需要4字节编码的planes来说，utf8_unicode_ci这种collation是无法支持。当使用4字节的字符（如emoji与B区以后的统一汉字）对使用此种collation的字段进行增删查改时，数据库会报一个非法字符的异常。而utf8mb4则没有此问题。由此也看出，utf8mb4_unicode_ci是utf8_unicode_ci的超集。emoji储存到数据库需要4个字节bytes,需要字段的字符集设置成为utf8mb4，  设置字段字符集为utf8mb4，字符集校对utf8mb4_unicode_cimysql配置和修改字符集  如果是已经存在的项目，现在存在的数据表和未来创建的数据表每个字段都支持4个字节(emoji)的存储，那么需要修改修改配置文件、已存在的数据库字符集、数据表字符集、字段字符集修改mysql配置文件[client]no-beepdefault-character-set = utf8mb4# pipe# socket=0.0port=7349[mysql]no-beep#default-character-set=utf8default-character-set = utf8mb4[mysqld]#character-set-server=utf8character-set-server = utf8mb4collation-server = utf8mb4_unicode_ci修改数据库的字符集ALTER SCHEMA `lti`  DEFAULT CHARACTER SET utf8mb4  DEFAULT COLLATE utf8mb4_unicode_ci ;修改表的字符集ALTER TABLE `lti`.`item` CHARACTER SET = utf8mb4 , COLLATE = utf8mb4_unicode_ci ;修改字段的字符集ALTER TABLE `lti`.`item` CHANGE COLUMN `item_text` `item_text` TEXT CHARACTER SET 'utf8mb4' COLLATE 'utf8mb4_unicode_ci' NULL DEFAULT NULL ;  如果只需要某个字段支持emoji4字节存储，可以直接修改这个字段的字符集就可以了，不用修改配置文件等。ALTER TABLE `lti`.`item` CHANGE COLUMN `item_text` `item_text` TEXT CHARACTER SET 'utf8mb4' COLLATE 'utf8mb4_unicode_ci' NULL DEFAULT NULL ;mysql odbc driver 不兼容utf8mb4如果服务端脚本语言Asp使用的mysql odbc driver操作数据库，涉及到utf8mb4的字段会出现错误，试过了很多版本的mysql-connector-odbc-8.0.x-winx64.msi都不可以，最后安装使用mariadb-connector-odbc-3.0.9-win64,解决了odbcd dirver不兼容utf8mb4的问题其他服务端脚本语言PHP没有使用mysql odbc driver没有发现问题。参考资料  mariadb odbc driver 3.0.9  mysql odbc driver 历史版本  Unicode 维基百科  emoji 维基百科  emoji unicode UTF-8 =&gt; https://apps.timwhitlock.info/emoji/tables/unicode]]></content>
      <categories>
        
          <category> mysql </category>
        
      </categories>
      <tags>
        
          <tag> mysql </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Git学习笔记]]></title>
      <url>/git/2019/09/23/Git-learing/</url>
      <content type="text"><![CDATA[Git配置，获取Git仓库，远程仓库管理，合并Commit知识点  repository //仓库  git本地仓库  git远程仓库(github或搭建服务端git仓库)  staged files //Changes to be committed 缓存区文件  unstaged files //Changes not staged for commit 已跟踪文件，并且修改后为加入缓存区文件  Untracked Files // 未跟踪的文件安装Git  用浏览器打开Git官方网址https://git-scm.com/downloads,  选择适配自己电脑系统的Git(Mac、Windows、Linux/Unix)配置用户信息全局配置$ git config --global user.name "Zhao QH"$ git config --global user.email "Zhaoqhu@gmail.com"局部配置$ cd ./git_programs/special_program$ git config user.name "ZhaoQingHu"$ git config user.email "izhaoqinghu@gmail.com"创建本地Git仓库$ cd ./git_programs/first_git$ echo "# zhaoqhu.github.io" &gt;&gt; README.md$ git init$ git add README.md$ git commit -m "first commit"git Commit提交git commit -m "提交信息"#将本次提交追加到上一次提交，不会产生新的commitIDgit commit -m "新的提交信息" --amend使用SSH连接到GitHub本地计算机SSH设置参考连接：https://help.github.com/cn/articles/connecting-to-github-with-ssh一台计算机配置一个Github账户SSH密钥  执行下面的shell命令列出已存在的SSH密钥    $ ls -al ~/.ssh        如果.ssh目录下不为空可能包含以下文件，说明本地计算机已经存在SSH密钥,否则本地计算机尚未生成SSH密钥： id_dsa.pub，id_ecdsa.pub，id_ed25519.pub，id_rsa.pub    生成新的SSH密钥     $ ssh-keygen        如果~/.ssh目录下没有文件，生成新的SSH密钥，按回车键几次后生成了id_rsa.pub，id_dsa.pub    复制id_rsa.pub这个文件里的内容添加到gihub账户，可以使用下面的命令也可以直接用编辑器或者VIM打开*.pub文件进行Copy    $ clip &lt; ~/.ssh/id_rsa.pub        添加到Github账户 Github账户=&gt;settings=&gt;SSH and GPG Keys=&gt;New SSH Key  使用下方的命令，测试账号配置是否成功    $ ssh -T git@github.com        一台计算机配置多个Github账户SSH密钥    本地计算机生成SSH密钥    $ ssh-keygen  -t rsa    -f ~/.ssh/github_zhaoqhu   -C "zhaoqhu@gmail.com"        ssh-keygen -t 密钥类型  -f 密钥文件路径及名称  -C 备注信息    检查~/.ssh目录下是否有config文件，添加一下内容    #Github account oneHost git.github.comHostName github.comIdentityFile ~/.ssh/id_rsa#Github account twoHost zhaoqhu.github.comHostName github.comIdentityFile ~/.ssh/github_zhaoqhu        复制~/.ssh目录下的github_zhaoqhu.pub文件里的内容=》githu帐号=&gt;settings=&gt;SSH and GPG Keys=&gt;New SSH Key  测试帐号配置是否成功$ ssh -T git@zhaoqhu.github.com管理远程仓库查看远程仓库$ git remote -v添加远程仓库$ git remote add orgin git@zhaoqhu.github.com:zhaoqhu/zhaoqhu.github.io.gitgit remote add 名称 URL重命名远程仓库$ git remote rename origin destination将远程仓库名称从 ‘origin’ 更改为 ‘destination’删除远程$ git remote rm destinationgit remote rm 远程名称修改远程仓库URL  方法一git remote -v  #查看远端地址git remote #查看远端仓库名git remote set-url origin https://gitee.com/xx/xx.git (新地址)  方法二git remote rm origin #删除远程的仓库git remote add origin  https://gitee.com/xx/xx.git(新地址) #重新添加远程仓库注：git remote rm 不会从服务器中删除远程仓库。 它只是从本地仓库中删除远程及其引用。  方法三直接修改.git目录下的config配置文件[core]	repositoryformatversion = 0	filemode = false	bare = false	logallrefupdates = true	symlinks = false	ignorecase = true[remote "origin"]	#将这里=号后的值换成需要的远程仓库值	url = git@github.com:zhaoqhu/zhaoqhu.github.io.git	fetch = +refs/heads/*:refs/remotes/origin/*[branch "master"]	remote = origin	merge = refs/heads/mastergit设置忽略目录和文件网上查询有三种方法可以实现忽略目录和文件，本方法使用在.git版本库的同级目录下添加.gitignore文件，只能忽略那些原来没有被track的文件，如果某些文件已经被纳入了版本管理中，则修改.gitignore是无效的里面的解决已经在版本库中的目录或者文件不能被忽略#比如_site目录已经在版本库中，执行下面的命令将_site目录变成未跟踪状态Untrackedgit rm --cached _sitegit commit -m "update _site gitignore".gitignore文件内容如下#忽略_site文件夹及文件夹下文件_site/*_theme_packages/*Thumbs.db.DS_Store!.gitkeep.rbenv-version.rvmrc/vendor合并Commit  git log -n查看Commit提交历史记录$ git log -n 6commit 8365c47d028c2e1a33f6c12b89c71d94757e18ae (HEAD -&gt; master, origin/master)Author: Zhao QH &lt;zhaoqhu@gmail.com&gt;Date:   Mon Sep 23 17:34:43 2019 +0800    fix:合并3commit 1485a27e8fb6031186422273190da2f25de65c5dAuthor: Zhao QH &lt;zhaoqhu@gmail.com&gt;Date:   Mon Sep 23 15:53:35 2019 +0800    modify _config searchcommit b26a1f5d0c649823a50b85e122f8eab07e2479adAuthor: Zhao QH &lt;zhaoqhu@gmail.com&gt;Date:   Mon Sep 23 15:19:10 2019 +0800    modify _config.ymlcommit 30a89ae0bcc3600adcf3ed042c9df2d58a1f2d89Author: Zhao QH &lt;zhaoqhu@gmail.com&gt;Date:   Mon Sep 23 15:06:52 2019 +0800    modify _config.ymlcommit cd574a978e947cf1ef92c8d68bfdfb39fe954798Author: Zhao QH &lt;zhaoqhu@gmail.com&gt;Date:   Mon Sep 23 11:32:30 2019 +0800    jekyll-theme-next template initcommit 823d9a66db7482ebdf52e20b4f67b9786e9e28f8Author: Zhao QH &lt;zhaoqhu@gmail.com&gt;Date:   Wed Sep 18 14:45:29 2019 +0800    first commit  git rebase -i 后面的参数可以是HEAD~5,或者是Commit的ID号(example:823d9a66db7482ebdf52e20b4f67b9786e9e28f8)$ git rebase -i HEAD~5   按下回车后，我们会进入到这么一个界面，最上面显示的几行是提交历史记录，按提交的时间倒序，最上面的是最早Commit的，pick cd574a9 jekyll-theme-next template initpick 30a89ae modify _config.ymlpick b26a1f5 modify _config.ymlpick 1485a27 modify _config searchpick 8365c47 fix:合并3# Rebase 823d9a6..8365c47 onto 823d9a6 (5 commands)## Commands:# p, pick = use commit# r, reword = use commit, but edit the commit message# e, edit = use commit, but stop for amending# s, squash = use commit, but meld into previous commit# f, fixup = like "squash", but discard this commit's log message# x, exec = run command (the rest of the line) using shell# d, drop = remove commit## These lines can be re-ordered; they are executed from top to bottom.## If you remove a line here THAT COMMIT WILL BE LOST.## However, if you remove everything, the rebase will be aborted.## Note that empty commits are commented out  把需要合并的Commit前面的pick改成squash或者s如下,pick cd574a9 jekyll-theme-next template initpick 30a89ae modify _config.ymlpick b26a1f5 modify _config.ymlpick 1485a27 modify _config searchs 8365c47 fix:合并3# Rebase 823d9a6..8365c47 onto 823d9a6 (5 commands)## Commands:# p, pick = use commit# r, reword = use commit, but edit the commit message# e, edit = use commit, but stop for amending# s, squash = use commit, but meld into previous commit# f, fixup = like "squash", but discard this commit's log message# x, exec = run command (the rest of the line) using shell# d, drop = remove commit## These lines can be re-ordered; they are executed from top to bottom.## If you remove a line here THAT COMMIT WILL BE LOST.## However, if you remove everything, the rebase will be aborted.## Note that empty commits are commented out  然后按ESC键=&gt;Shift+:键=&gt;wq,保存退出,如果一切顺利会弹出一个画面,如果文件有冲突需要解决后，然后执行git rebase –continue$git rebase --continue错误解决后，可以调到下面的界面# This is a combination of 2 commits.# This is the 1st commit message:modify _config search# This is the commit message #2:fix:合并3# Please enter the commit message for your changes. Lines starting# with '#' will be ignored, and an empty message aborts the commit.## Date:      Mon Sep 23 15:53:35 2019 +0800## interactive rebase in progress; onto 823d9a6# Last commands done (5 commands done):#    pick 1485a27 modify _config search#    squash 8365c47 fix:合并3# No commands remaining.# You are currently rebasing branch 'master' on '823d9a6'.## Changes to be committed:#       modified:   Gemfile.lock#       modified:   _config.yml#       new file:   "_posts/2019-09-23-Git\345\255\246\344\271\240\347\254\224\350\256\260.md"## Untracked files:#       .jekyll-metadata  合并Commit的信息fix:合并4# Please enter the commit message for your changes. Lines starting# with '#' will be ignored, and an empty message aborts the commit.## Date:      Mon Sep 23 15:53:35 2019 +0800## interactive rebase in progress; onto 823d9a6# Last commands done (5 commands done):#    pick 1485a27 modify _config search#    squash 8365c47 fix:合并3# No commands remaining.# You are currently rebasing branch 'master' on '823d9a6'.## Changes to be committed:#       modified:   Gemfile.lock#       modified:   _config.yml#       new file:   "_posts/2019-09-23-Git\345\255\246\344\271\240\347\254\224\350\256\260.md"## Untracked files:#       .jekyll-metadata  合并完成注：git rebase 操作应该只用于本地尚未提交到远程仓库的 commit，一旦 push 到远端仓库，则不再允许修改 commit，否则可能会给其他开发者带来很多麻烦。尤其是多人协作时，千万要注意。。github page  How to Build a Static Jekyll Site with Github Pages    参考资料    使用 Git =&gt;https://help.github.com/cn/categories/using-git  git Book =&gt;https://git-scm.com/book/zh/v2  使用 SSH 连接到 GitHub =&gt;https://help.github.com/cn/articles/connecting-to-github-with-ssh  A3.1 附录 C: Git 命令 - 设置与配置 =&gt;https://git-scm.com/book/zh/v2/%E9%99%84%E5%BD%95-C%3A-Git-%E5%91%BD%E4%BB%A4-%E8%AE%BE%E7%BD%AE%E4%B8%8E%E9%85%8D%E7%BD%AE]]></content>
      <categories>
        
          <category> Git </category>
        
      </categories>
      <tags>
        
          <tag> Git </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
</search>
